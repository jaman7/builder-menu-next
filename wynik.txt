.eslintrc.json
{
  "root": true,
  "env": {
    "browser": true,
    "es6": true,
    "node": true,
    "jest": true
  },
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": 2022,
    "sourceType": "module",
    "project": "./tsconfig.json"
  },
  "settings": {
    "react": {
      "version": "detect"
    }
  },
  "extends": [
    "next/core-web-vitals",
    "plugin:@typescript-eslint/recommended",
    "plugin:react/recommended",
    "plugin:react-hooks/recommended",
    "plugin:jsx-a11y/recommended",
    "plugin:tailwindcss/recommended",
    "plugin:prettier/recommended",
    "plugin:jest/recommended",
    "plugin:jest/style"
  ],
  "plugins": [
    "@typescript-eslint",
    "react",
    "react-hooks",
    "jsx-a11y",
    "tailwindcss",
    "jest"
  ],
  "rules": {
    "@typescript-eslint/no-unused-vars": [
      "error",
      {
        "argsIgnorePattern": "^_"
      }
    ],
    "react/jsx-filename-extension": [
      "error",
      {
        "extensions": [
          ".tsx"
        ]
      }
    ],
    "tailwindcss/no-custom-classname": "off",
    "prettier/prettier": "error",
    "@typescript-eslint/no-explicit-any": "warn",
    "react/prop-types": "off",
    "jest/consistent-test-it": "error",
    "jest/no-disabled-tests": "warn",
    "jest/no-focused-tests": "error",
    "jest/no-identical-title": "error",
    "jest/prefer-to-have-length": "warn",
    "jest/valid-expect": "error",
    "react/display-name": "off",
    "react/react-in-jsx-scope": "off"
  },
  "ignorePatterns": [
    "node_modules/",
    ".next/",
    "dist/",
    "out/"
  ]
}

.prettierrc
{
  "tabWidth": 2,
  "useTabs": false,
  "singleQuote": true,
  "semi": true,
  "bracketSpacing": true,
  "arrowParens": "always",
  "trailingComma": "es5",
  "bracketSameLine": false,
  "printWidth": 140,
  "endOfLine": "auto",
  "overrides": [
    {
      "files": "*.html",
      "options": {
        "parser": "html"
      }
    },
    {
      "files": "*.component.html",
      "options": {
        "parser": "react"
      }
    },
    {
      "files": "*.scss",
      "options": {
        "singleQuote": false
      }
    }
  ]
}

jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  testMatch: ['**/?(*.)+(spec|test).[tj]s?(x)'],
  modulePathIgnorePatterns: ['/node_modules/', '/dist/', '/.next/'],
  transform: {
    '^.+\\.(ts|tsx)$': ['ts-jest', { tsconfig: '<rootDir>/tsconfig.json' }],
  },
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'], // Używaj TypeScriptowego pliku setup
};

jest.setup.ts
import '@testing-library/jest-dom';
import fetchMock from 'jest-fetch-mock';

fetchMock.enableMocks();

next-env.d.ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.

next.config.ts
import { NextConfig } from 'next';

const nextConfig: NextConfig = {
  reactStrictMode: true,
  sassOptions: {
    includePaths: ['./src/assests/scss'], // Zmiana na właściwą ścieżkę
  },
};

export default nextConfig;

package.json
{
  "name": "builder-menu-next",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "eslint . --ext ts,tsx --fix",
    "prettier:format": "prettier --write --html-whitespace-sensitivity ignore src/**/*{.tsx,.ts,.js,.jsx,.json,.css,.scss,.html}",
    "prepare": "husky .husky",
    "test": "jest --watchAll",
    "test:ci": "jest --runInBand",
    "lint:test": "eslint src/**/*.test.{ts,tsx} --fix"
  },
  "lint-staged": {
    "*.{js,jsx,ts,tsx,yml,html,md,json}": [
      "eslint --fix",
      "git add"
    ],
    "*.{css,scss}": [
      "stylelint --fix",
      "git add"
    ]
  },
  "dependencies": {
    "@dnd-kit/core": "^6.2.0",
    "@dnd-kit/sortable": "^9.0.0",
    "@hookform/resolvers": "^3.9.1",
    "classnames": "^2.5.1",
    "framer-motion": "^11.12.0",
    "immer": "^10.1.1",
    "next": "15.0.3",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.53.2",
    "react-window": "^1.8.10",
    "yup": "^1.4.0",
    "zustand": "^5.0.1"
  },
  "devDependencies": {
    "@babel/core": "^7.26.0",
    "@babel/preset-env": "^7.26.0",
    "@next/bundle-analyzer": "^15.0.3",
    "@testing-library/jest-dom": "^6.6.3",
    "@types/jest": "^29.5.14",
    "@types/node": "^20.17.8",
    "@types/react": "^18.3.12",
    "@types/react-dom": "^18.3.1",
    "@types/react-window": "^1.8.8",
    "@typescript-eslint/eslint-plugin": "^8.16.0",
    "@typescript-eslint/parser": "^8.16.0",
    "autoprefixer": "^10.4.20",
    "babel-jest": "^29.7.0",
    "eslint": "^8.57.1",
    "eslint-config-next": "^15.0.3",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-jest": "^28.9.0",
    "eslint-plugin-jsx-a11y": "^6.10.2",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-react": "^7.37.2",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-tailwindcss": "^3.11.0",
    "husky": "^9.1.7",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "jest-fetch-mock": "^3.0.3",
    "lint-staged": "^15.2.10",
    "postcss": "^8.4.49",
    "prettier": "^3.3.3",
    "prettier-plugin-tailwindcss": "^0.6.9",
    "react-test-renderer": "^18.3.1",
    "sass": "^1.81.0",
    "stylelint": "^16.10.0",
    "stylelint-config-recommended": "^14.0.1",
    "stylelint-config-standard-scss": "^13.1.0",
    "tailwindcss": "^3.4.15",
    "ts-jest": "^29.2.5",
    "typescript": "^5.7.2"
  }
}

postcss.config.js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/**/*.{js,ts,jsx,tsx}',
    './src/assests/scss/**/*.{scss,css}', // Dodano SCSS
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};

tsconfig.json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "*"
      ],
      "@/components/*": [
        "src/app/components/*"
      ],
      "@/store/*": [
        "src/app/store/*"
      ],
      "@/shared/*": [
        "src/app/shared/*"
      ],
      "@/assests/*": [
        "assests/*"
      ],
      "@/scss/*": [
        "src/assests/scss/*"
      ]
    },
    "target": "es6",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "types": [
      "jest",
      "node"
    ]
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "dist",
    ".next"
  ]
}

src\app\head.tsx
export default function Head() {
  return (
    <>
      <title>Create Next App</title>
      <meta name="description" content="Generated by Mike van Peeren" />
      <link rel="icon" href="/favicon.ico" />
    </>
  );
}

src\app\layout.tsx
import { Metadata } from 'next';
import { Inter } from 'next/font/google';
import React from 'react';
import '@/src/assests/scss/global.scss';

const inter = Inter({
  weight: ['400', '500', '600', '700'],
  style: ['normal', 'italic'],
  subsets: ['latin'],
});

export const metadata: Metadata = {
  title: 'Navigation Builder',
  description: 'Build and manage navigation menus with ease.',
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en" className={inter.className}>
      <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      </head>
      <body className="font-family-inter text-primary bg-page text-base font-normal antialiased">{children}</body>
    </html>
  );
}

src\app\page.tsx
'use client';

import React from 'react';
import MenuEditor from '@/components/builder-menu/MenuEditor';
import MultiLevelMenu from '@/components/primary-menu/MultiLevelMenu';

export default function Home() {
  return (
    <div className="block rounded-lg bg-transparent p-4">
      <MultiLevelMenu />
      <MenuEditor />
    </div>
  );
}

src\app\components\builder-menu\EmptyState.tsx
import React from 'react';
import Button, { ButtonVariant } from '@/shared/components/button/Button';
import PlusIcon from '@/shared/components/icons/PlusIcon';

export default function EmptyState({ onAdd }: { onAdd: () => void }) {
  return (
    <div className="bg-secondary flex flex-col items-center justify-center rounded-lg p-6">
      <p className="text-primary mb-2 text-center font-semibold">Menu jest puste</p>
      <p className="text-tertiary mb-2 text-center text-sm">W tym menu nie ma jeszcze żadnych linków</p>
      <Button handleClick={onAdd} variant={ButtonVariant.PRIMARY}>
        <PlusIcon />
        <span className="ml-1">Dodaj pozycję menu</span>
      </Button>
    </div>
  );
}

src\app\components\builder-menu\MenuEditor.const.tsx
import { defaultDropAnimation, DropAnimation, MeasuringStrategy } from '@dnd-kit/core';
import { CSS } from '@dnd-kit/utilities';

export const indentationWidth = 64;

export const measuring = {
  droppable: {
    strategy: MeasuringStrategy.Always,
  },
};

export const dropAnimationConfig: DropAnimation = {
  keyframes({ transform }) {
    return [
      { opacity: 1, transform: CSS.Transform.toString(transform.initial) },
      {
        opacity: 0,
        transform: CSS.Transform.toString({
          ...transform.final,
          x: transform.final.x + 5,
          y: transform.final.y + 5,
        }),
      },
    ];
  },
  easing: 'ease-in-out ',
  sideEffects({ active }) {
    active.node.animate([{ opacity: 0 }, { opacity: 1 }], {
      duration: defaultDropAnimation.duration,
      easing: defaultDropAnimation.easing,
    });
  },
};

src\app\components\builder-menu\MenuEditor.model.tsx
import { INavItem } from '@/store/navigationStore';

export interface IFlattenedItem extends INavItem {
  parentId: number | string | null;
  order: number;
  level: number;
}

export interface IProjected {
  level?: number;
  maxDepth?: number;
  minDepth?: number;
  parentId?: number | string | null;
}

src\app\components\builder-menu\MenuEditor.tsx
import React, { useState } from 'react';
import Button, { ButtonVariant } from '@/shared/components/button/Button';
import PlusIcon from '@/shared/components/icons/PlusIcon';
import MenuForm from './MenuForm';
import useNavigationStore from '@/store/navigationStore';
import MenuListDrag from './MenuListDrag';
import EmptyState from './EmptyState';
import Collapse from '@/shared/components/Collapse';

interface IProps {
  style?: 'bordered' | 'shadow';
}

export const MenuEditor: React.FC<IProps> = ({ style = 'bordered' }) => {
  const { navigation } = useNavigationStore();
  const [addingNew, setAddingNew] = useState(false);

  return (
    <div className="border-primary block rounded-lg border border-solid bg-transparent">
      {navigation.length > 0 ? <MenuListDrag style={style} /> : <EmptyState onAdd={() => setAddingNew(true)} />}

      {addingNew && (
        <Collapse isOpen={addingNew} padding={{ paddingBottom: 0, paddingTop: 20 }}>
          <MenuForm onSubmit={() => setAddingNew(false)} onCancel={() => setAddingNew(false)} />
        </Collapse>
      )}
      {navigation.length > 0 && (
        <div className="block px-6 py-5">
          <Button handleClick={() => setAddingNew(true)} variant={ButtonVariant.SECONDARY}>
            <span className="flex items-center space-x-2">
              <PlusIcon />
              <span>Dodaj pozycję menu</span>
            </span>
          </Button>
        </div>
      )}
    </div>
  );
};

export default MenuEditor;

src\app\components\builder-menu\MenuForm.tsx
import React, { useEffect } from 'react';
import { FormProvider, useForm } from 'react-hook-form';
import * as yup from 'yup';
import { yupResolver } from '@hookform/resolvers/yup';
import Button, { ButtonVariant } from '@/shared/components/button/Button';
import { createConfigForm } from '@/shared/helpers/form-config';
import FormElements from '@/shared/components/formElements/FormElements';
import { IFormElementsConfig } from '@/shared/components/formElements/FormElements.model';
import useNavigationStore, { INavItem } from '@/store/navigationStore';
import TrashIcon from '@/shared/components/icons/TrashIcon';

export const formConfig: IFormElementsConfig = {
  label: {
    placeholder: 'np. Promocje',
    header: 'Nazwa',
  },
  url: {
    formCellType: 'input-search',
    placeholder: 'Wklej lub wyszukaj',
    header: 'Link',
  },
};

export interface IFormData {
  url?: string | undefined;
  label: string;
}

interface IProps {
  data?: INavItem | null;
  parentId?: string | number | null;
  onSubmit: (data: INavItem | null) => void;
  onCancel: () => void;
}

const schema = yup.object({
  label: yup.string().required('Nazwa jest wymagana').max(50, 'Nazwa nie może przekraczać 50 znaków'),
  url: yup.string().test('conditional-url', 'Podaj poprawny URL lub odnośnik zaczynający się od #', (value) => {
    if (!value) return false;
    return /^#/.test(value) || yup.string().url().isValidSync(value);
  }),
});

const MenuForm: React.FC<IProps> = ({ data, parentId, onSubmit, onCancel }) => {
  const { addNavItem, updateNavItem, deleteNavItem } = useNavigationStore();

  const methods = useForm({
    resolver: yupResolver(schema),
    mode: 'onChange',
    defaultValues: { label: '', url: '' },
  });

  const { setValue, formState } = methods;
  const { isValid } = formState;

  useEffect(() => {
    const { label, url } = data || {};
    setValue('label', !parentId ? label || '' : '');
    setValue('url', !parentId ? url || '' : '');
  }, [data, parentId, setValue]);

  const handleSubmit = (formData: IFormData) => {
    const dataForm = { ...formData };
    const { id } = data || {};
    if (!id) addNavItem(dataForm, parentId ?? null);
    if (id) updateNavItem(id, dataForm);
    onSubmit(data as INavItem);
  };

  const handleDelete = () => {
    const { id } = data || {};
    if (id) {
      onSubmit(null);
      deleteNavItem(id);
    }
  };

  const formElements = createConfigForm(formConfig, { prefix: 'menu' });

  return (
    <FormProvider {...methods}>
      <form onSubmit={methods.handleSubmit(handleSubmit)} className="border-primary rounded-lg border border-solid bg-white p-6">
        <div className="grid grid-cols-[1fr,auto] gap-x-3">
          <div className="block w-full">
            {formElements?.map((config) => (
              <FormElements key={config.formControlName} formControlName={config.formControlName} config={config} />
            ))}
          </div>

          <div className="block">
            <Button round={true} handleClick={handleDelete} disabled={!data?.id}>
              <TrashIcon />
            </Button>
          </div>
        </div>

        <div className="flex gap-x-2 pt-5">
          <Button handleClick={onCancel} variant={ButtonVariant.SECONDARY}>
            Anuluj
          </Button>
          <Button type="submit" variant={ButtonVariant.TERTIARY} disabled={!isValid}>
            Zapisz
          </Button>
        </div>
      </form>
    </FormProvider>
  );
};

export default MenuForm;

src\app\components\builder-menu\MenuListDrag.tsx
import React from 'react';
import {
  closestCenter,
  DndContext,
  DragEndEvent,
  DragMoveEvent,
  DragOverEvent,
  DragOverlay,
  DragStartEvent,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
} from '@dnd-kit/core';
import { arrayMove, SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { useCallback, useMemo } from 'react';
import useNavigationStore from '@/store/navigationStore';
import { dropAnimationConfig, indentationWidth, measuring } from './MenuEditor.const';
import { createPortal } from 'react-dom';
import SortableItem from './SortableItem';
import {
  adjustTranslate,
  buildTreeFromFlatten,
  childrenCount,
  childrensItems,
  findIdPushChildren,
  levelProjection,
  updateOrderAndLevel,
} from '@/shared/helpers/tree';

interface IProps {
  style?: 'bordered' | 'shadow';
}

const MenuListDrag: React.FC<IProps> = ({ style }) => {
  const { navigation, setDragState, resetDragState, setNavigation } = useNavigationStore();
  const flattenedMenu = useNavigationStore((state) => state.flattenedNavigation);
  const { activeId, overId, offsetLeft } = useNavigationStore((state) => state.dragState);

  const activeItem = useMemo(() => (activeId ? flattenedMenu?.find(({ id }) => id === activeId) : null), [activeId, flattenedMenu]);

  const projected = useMemo(() => {
    if (!activeId || !overId) return null;
    return levelProjection(flattenedMenu, activeId, overId, offsetLeft ?? 0, indentationWidth);
  }, [activeId, overId, offsetLeft, flattenedMenu]);

  const sortedIds = useMemo(() => flattenedMenu?.map(({ id }) => id) ?? [], [flattenedMenu]) ?? [];

  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 5,
      },
    }),
    useSensor(KeyboardSensor)
  );

  const resetState = useCallback((): void => {
    resetDragState();
    document.body.style.setProperty('cursor', '');
  }, [resetDragState]);

  const handleDragStart = useCallback(
    ({ active }: DragStartEvent) => {
      const isDragIcon = document.querySelector('.drag-handle');
      if (!isDragIcon) return;
      setDragState({ activeId: active.id, overId: active.id });
      document.body.style.cursor = 'grabbing';
    },
    [setDragState]
  );

  const handleDragMove = useCallback(
    ({ delta }: DragMoveEvent) => {
      setDragState({ offsetLeft: delta.x });
    },
    [setDragState]
  );

  const handleDragOver = useCallback(
    ({ over }: DragOverEvent) => {
      setDragState({ overId: over?.id ?? null });
    },
    [setDragState]
  );

  const handleDragCancel = (): void => {
    resetState();
  };

  const handleDragEnd = useCallback(
    ({ active, over }: DragEndEvent): void => {
      if (!projected || !over) {
        resetState();
        return;
      }
      const { level, parentId } = projected;
      const clonedItems = [...flattenedMenu];
      const overIndex = clonedItems.findIndex(({ id }) => id === over.id);
      const activeIndex = clonedItems.findIndex(({ id }) => id === active.id);
      if (activeIndex < 0 || overIndex < 0) {
        resetState();
        return;
      }

      const activeTreeItem = clonedItems[activeIndex];
      const activeTreeItemChildren = activeTreeItem.children ?? [];
      clonedItems[activeIndex] = { ...activeTreeItem, level: level ?? 0, parentId: parentId ?? null };
      const sortedItems = arrayMove(clonedItems, activeIndex, overIndex);
      const newItems = buildTreeFromFlatten(sortedItems);
      const newNavigation = updateOrderAndLevel(findIdPushChildren(active.id, newItems, activeTreeItemChildren));
      setNavigation(newNavigation);
      resetDragState();
    },
    [flattenedMenu, projected, resetDragState, resetState, setNavigation]
  );

  return (
    <DndContext
      sensors={sensors}
      collisionDetection={closestCenter}
      measuring={measuring}
      onDragStart={handleDragStart}
      onDragMove={handleDragMove}
      onDragOver={handleDragOver}
      onDragEnd={handleDragEnd}
      onDragCancel={handleDragCancel}
    >
      <SortableContext items={sortedIds} strategy={verticalListSortingStrategy}>
        <ul className="bg-secondary flex flex-col rounded-lg">
          {flattenedMenu &&
            flattenedMenu?.map((item) => (
              <SortableItem
                key={item.id}
                id={item.id}
                value={item.id?.toString()}
                item={item}
                show={activeId && activeItem ? true.toString() : false.toString()}
                indentationWidth={indentationWidth}
                depth={item.id === activeId && projected ? projected.level : item.level}
                indicator={style === 'bordered'}
                childCount={childrenCount(navigation ?? [], activeId) + 1}
              />
            ))}

          {createPortal(
            <DragOverlay
              dropAnimation={dropAnimationConfig}
              modifiers={style === 'bordered' ? [adjustTranslate] : undefined}
              style={{ overflow: 'hidden' }}
            >
              {activeId && activeItem?.id === activeId ? (
                <SortableItem
                  id={activeId}
                  depth={activeItem?.level > 0 ? 0 : activeItem?.level}
                  item={flattenedMenu?.find((el) => el.id === activeId)}
                  clone={activeId !== null && childrenCount(flattenedMenu ?? [], activeId) > 0}
                  childCount={childrenCount(navigation ?? [], activeId) + 1}
                  value={activeId?.toString()}
                  indentationWidth={indentationWidth}
                  navChildren={childrensItems(navigation, activeId)}
                />
              ) : null}
            </DragOverlay>,
            document.body
          )}
        </ul>
      </SortableContext>
    </DndContext>
  );
};

export default MenuListDrag;

src\app\components\builder-menu\RecursiveItem.tsx
import { INavItem } from '@/store/navigationStore';
import MenuItem from './MenuItem/MenuItem';
import { indentationWidth } from './MenuEditor.const';
import React from 'react';

interface IProps {
  item: INavItem;
  nDepth: number;
}

const RecursiveItem: React.FC<IProps> = ({ item, nDepth }) => {
  const newDepth = nDepth + 1;
  return (
    <>
      <div
        className="RecursiveItem"
        style={{
          marginLeft: `${nDepth * indentationWidth}px`,
          boxSizing: 'border-box',
        }}
      >
        <MenuItem item={item} id={item.id} />
      </div>
      {item?.children?.map((el) => {
        return <RecursiveItem key={`${el.id}-newDepth`} item={el} nDepth={newDepth} />;
      })}
    </>
  );
};

export default React.memo(RecursiveItem);

src\app\components\builder-menu\SortableItem.tsx
import { AnimateLayoutChanges, useSortable } from '@dnd-kit/sortable';
import { INavItem } from '@/store/navigationStore';
import { CSSProperties } from 'react';
import { CSS } from '@dnd-kit/utilities';
import TreeItem from './TreeItem';
import React from 'react';

interface IProps {
  id: string | number;
  item?: INavItem;
  navChildren?: INavItem[];
  show?: string;
  childCount?: number;
  value?: string | number;
  indicator?: boolean;
  clone?: boolean;
  depth?: number;
  indentationWidth?: number;
  // onEdit?: () => void;
}

const SortableItem: React.FC<IProps> = ({ id, depth, ...props }) => {
  const animateLayoutChanges: AnimateLayoutChanges = ({ isSorting, wasDragging }) => (isSorting || wasDragging ? false : true);

  const { attributes, isDragging, isSorting, listeners, setDraggableNodeRef, setDroppableNodeRef, transform, transition } = useSortable({
    id,
    animateLayoutChanges,
    disabled: true,
  });

  const style: CSSProperties = {
    transform: CSS.Translate.toString(transform),
    transition,
    boxSizing: 'border-box',
  };

  return (
    <TreeItem
      ref={setDraggableNodeRef}
      wrapperRef={setDroppableNodeRef}
      style={style}
      depth={depth}
      ghost={isDragging}
      disableInteraction={isSorting}
      handleProps={{
        ...attributes,
        ...listeners,
      }}
      id={id}
      {...props}
    />
  );
};

export default SortableItem;

src\app\components\builder-menu\TreeItem.scss
.menu-item {
  list-style: none;
  box-sizing: border-box;
  -webkit-font-smoothing: subpixel-antialiased;

  &.clone {
    pointer-events: none;

    & .item-detail {
      width: 100%;
      min-width: 100%;
      max-width: 100%;
    }
  }

  &.ghost {
    &.indicator {
      opacity: 1;
      position: relative;
      z-index: 1;
      margin-bottom: -1px;

      & .item-detail {
        position: relative;
        width: 100%;
        min-width: 100%;
        max-width: 100%;

        border: 1px dashed var(--button-primary-bg);
        background-color: var(--bg-page);
        opacity: 0.5;

        & > * {
          opacity: 0;
          height: 0;
        }
      }
    }

    &:not(.indicator) {
      opacity: 0.5;
    }

    & .item-detail > * {
      box-shadow: none;
      background-color: transparent;
    }
  }

  .item-detail {
    height: 76px;
    position: relative;
  }
}

.children-clone-list {
  position: relative;
  overflow: hidden;
  width: 100%;
  max-width: 100%;
  display: flex;
  flex-direction: column;
}

.disableInteraction {
  pointer-events: none;
}

.disableSelection {
  user-select: none;
  -webkit-user-select: none;
}

src\app\components\builder-menu\TreeItem.tsx
import React, { AriaAttributes, Suspense } from 'react';
import { forwardRef, HTMLAttributes, useState } from 'react';
import useNavigationStore, { INavItem } from '@/store/navigationStore';
import classNames from 'classnames';
import MenuItem from './MenuItem/MenuItem';
import Collapse from '@/shared/components/Collapse';
import MenuForm from './MenuForm';
const RecursiveItem = React.lazy(() => import('./RecursiveItem'));
import './TreeItem.scss';

export interface IProps extends Omit<HTMLAttributes<HTMLLIElement>, 'id'> {
  id: string | number;
  item?: INavItem;
  navChildren?: INavItem[];
  childCount?: number;
  clone?: boolean;
  depth?: number;
  disableInteraction?: boolean;
  ghost?: boolean;
  handleProps?: AriaAttributes & HTMLAttributes<HTMLDivElement>;
  indicator?: boolean;
  value?: string | number;
  show?: string;
  indentationWidth?: number;
  wrapperRef?(node: HTMLLIElement): void;
}

const TreeItem = forwardRef<HTMLDivElement, IProps>(
  (
    {
      id,
      item,
      navChildren,
      childCount,
      clone,
      depth,
      indentationWidth,
      disableInteraction,
      ghost,
      handleProps,
      indicator,
      style,
      wrapperRef,
      ...props
    },
    ref
  ) => {
    const [parentId, setParentId] = useState<string | number | null>(null);
    const { toggleCollapse, isCollapseOpen, deleteNavItem } = useNavigationStore(); // Globalny stan
    const openCollapse = isCollapseOpen(id);

    const calcIndentationWidth = (level: number | null) => (indentationWidth || 0) * (level || 0);

    const ItemStyle = {
      ...(!clone
        ? {
            paddingLeft: `${calcIndentationWidth(depth as number)}px`,
          }
        : {}),
    } as React.CSSProperties;

    const threeStyle = {
      ...style,
      height:
        (ghost && indicator) || (ghost && indicator && childCount && childCount - 1 > 0)
          ? `${(childCount as number) * 76 + ((childCount as number) - 1) * 3}px`
          : 'auto',
    } as React.CSSProperties;

    const styleLielement = classNames('flex justify-between w-full', {
      'menu-item': true,
      clone,
      ghost,
      indicator,
      disableInteraction,
    });

    const handleToggleCollapse = () => {
      toggleCollapse(id);
    };

    const onHandleEdit = (): void => {
      setParentId?.(null);
      handleToggleCollapse();
    };

    const onHandleDelete = (): void => {
      deleteNavItem(id);
    };

    const onHandleAddNew = (parentId?: string | number | null): void => {
      setParentId?.(parentId ?? null);
      handleToggleCollapse();
    };

    const onHandleCancel = (): void => {
      handleToggleCollapse();
      setParentId?.(null);
    };

    const onSubmitCloseForm = (): void => {
      handleToggleCollapse();
      setParentId?.(null);
    };

    const paddingEditCollapse = () => (parentId ? { paddingLeft: calcIndentationWidth(1) } : {});

    return (
      <li className={styleLielement} ref={wrapperRef} style={ItemStyle} {...props}>
        <div {...handleProps} className="item-detail w-full cursor-default" ref={ref} style={threeStyle}>
          <MenuItem onEdit={onHandleEdit} onDelete={onHandleDelete} onAddNew={(id) => onHandleAddNew(id)} item={item} id={id} />

          {clone && childCount && childCount > 1 ? (
            <div className={'children-clone-list'} style={{ overflow: 'hidden' }}>
              <Suspense fallback={<div>Ładowanie...</div>}>
                {navChildren &&
                  navChildren?.map((child) => {
                    return <RecursiveItem key={`${child.id}-clone`} item={child} nDepth={1} />;
                  })}
              </Suspense>
            </div>
          ) : null}

          <Collapse isOpen={openCollapse} padding={paddingEditCollapse()}>
            <MenuForm
              data={openCollapse && !parentId ? item : null}
              parentId={parentId && openCollapse ? parentId : null}
              onSubmit={() => onSubmitCloseForm()}
              onCancel={onHandleCancel}
            />
          </Collapse>
        </div>
      </li>
    );
  }
);

export default React.memo(TreeItem);

src\app\components\builder-menu\MenuItem\MenuItem.tsx
import React from 'react';
import { useSortable } from '@dnd-kit/sortable';
import DragIcon from '@/shared/components/icons/DragIcon';
import { INavItem } from '@/store/navigationStore';
import { UniqueIdentifier } from '@dnd-kit/core';
import classNames from 'classnames';
import MenuItemDetails from './MenuItemDetails';
import MenuItemActions from './MenuItemActions';

export interface IProps {
  id: string | number;
  item?: INavItem;
  onEdit?: () => void;
  onDelete?: () => void;
  onAddNew?: (parentId?: string | number) => void;
}

const MenuItem: React.FC<IProps> = ({ id, item, onEdit, onDelete, onAddNew }) => {
  const { attributes, listeners, setActivatorNodeRef } = useSortable({ id: id as UniqueIdentifier });
  const { level, order, children, label, url } = item || {};

  const styleClass = classNames(
    'three-details bg-white py-4 px-4 border-gray-color border border-solid border-secondary flex w-full items-center justify-between',
    { 'rounded-t-lg': order === 0 && level === 0, 'rounded-bl-lg': children && children?.length > 0 }
  );

  return (
    <div className={styleClass}>
      <div className="flex items-center">
        <i className="drag-handle cursor-move p-2.5 text-4xl" ref={setActivatorNodeRef} {...attributes} {...listeners}>
          <DragIcon />
        </i>

        <MenuItemDetails label={label ?? ''} url={url ?? ''} />
      </div>
      <MenuItemActions onEdit={onEdit} onDelete={onDelete} onAddNew={() => onAddNew?.(id)} />
    </div>
  );
};

export default React.memo(MenuItem);

src\app\components\builder-menu\MenuItem\MenuItemActions.tsx
import Button, { ButtonVariant } from '@/src/app/shared/components/button/Button';
import React from 'react';

export interface IProps {
  id?: string | number;
  onEdit?: () => void;
  onDelete?: () => void;
  onAddNew?: (parentId?: string | number) => void;
}

const MenuItemActions: React.FC<IProps> = ({ id, onEdit, onDelete, onAddNew }) => {
  return (
    <div className="flex items-center gap-x-0">
      <Button variant={ButtonVariant.SECONDARY} handleClick={onEdit} className="rounded-none text-sm first:rounded-l-lg">
        Edytuj
      </Button>
      <Button variant={ButtonVariant.SECONDARY} handleClick={onDelete} className="rounded-none text-sm">
        Usuń
      </Button>
      <Button variant={ButtonVariant.SECONDARY} handleClick={() => onAddNew?.(id)} className="rounded-none text-sm last:rounded-r-lg">
        Dodaj pod-menu
      </Button>
    </div>
  );
};

export default React.memo(MenuItemActions);

src\app\components\builder-menu\MenuItem\MenuItemDetails.tsx
import React from 'react';

const MenuItemDetails: React.FC<{ label: string; url: string }> = ({ label, url }) => {
  return (
    <div className="flex w-full flex-col">
      <span className="text-primary text-sm font-semibold">{label}</span>
      <span className="link-color text-sm">{url}</span>
    </div>
  );
};

export default React.memo(MenuItemDetails);

src\app\components\primary-menu\MultiLevelMenu.scss
.nav-menu {
  padding: 1rem 0;
  display: flex;
  justify-content: center;
}

.menu {
  margin: 0;
  padding: 0;
  display: flex;
  list-style: none;
  margin: 0;
  padding: 0;
  width: 100%;
  font-size: 14px;

  & .item {
    background-color: var(--bg-secondary);
    color: var(--text-primary);

    &.horizonatal {
      & svg {
        transform: rotate(90deg);
        transition: transform 250ms ease-in-out;
      }
    }

    &:hover {
      background-color: var(--button-primary-bg);
      color: var(--bg-secondary);

      & > .item-content > svg {
        transform: rotate(-90deg);
      }
    }

    &-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
  }

  & > .item {
    padding: 0.25rem 1rem;
    cursor: pointer;
    border: 1px solid var(--border-primary);
    border-radius: 5px;
    width: max-content;
    position: relative;

    &:hover {
      background-color: var(--button-primary-bg);
      color: var(--bg-secondary);

      & > ul.menu-dropdown {
        opacity: 1;
        visibility: visible;
        top: 100%;
        transition: 0.3s;
        pointer-events: auto;
      }
    }

    & > ul.menu-dropdown {
      position: absolute;
      z-index: 1000;
      top: 80%;
      margin: 0;
      left: 0;
      opacity: 0;
      visibility: hidden;
      transition: 0.3s;
      pointer-events: none;
      width: max-content;

      &::before {
        content: "";
        display: block;
        position: absolute;
        height: 10px;
        width: 100%;
        top: 0;
      }

      & .item {
        padding: 4px 1rem;
        cursor: pointer;
        border: 1px solid var(--border-primary);
        border-radius: 5px;
        position: relative;

        &.vertical > .item-content > svg {
          transform: rotate(0deg);
          transition: transform 250ms ease-in-out;
        }

        &:hover {
          & > .menu-dropdown {
            opacity: 1;
            visibility: visible;
            left: 100%;
            transition: 0.3s;
            pointer-events: auto;
          }

          & > .item-content svg {
            transform: rotate(-180deg);
          }
        }

        & ul.menu-dropdown {
          position: absolute;
          z-index: 1000;
          pointer-events: none;
          top: 0;
          left: 150%;
          opacity: 0;
          visibility: hidden;
          transition: 0.3s;
          width: max-content;
        }
      }
    }
  }
}

src\app\components\primary-menu\MultiLevelMenu.tsx
import React, { memo, useEffect } from 'react';
import classNames from 'classnames';
import CaretIcon from '@/shared/components/icons/CaretIcon';
import useNavigationStore, { INavItem } from '@/store/navigationStore';
import { buildTree } from '@/shared/helpers/tree';
import './MultiLevelMenu.scss';

const initialNavigation: INavItem[] = [
  { id: 1, label: 'Promocje', url: '#qqqqqqqqqqq', parentId: null, level: 0, order: 0 },
  { id: 2, label: 'Promocje 1', url: '#wwwwwwwwwwwwwwwww', parentId: 1, level: 1, order: 1 },
  { id: 3, label: 'Promocje 2', url: '#eeeeeeeeeeeee', parentId: 1, level: 1, order: 0 },
  { id: 4, label: 'Promocje 3', url: '#rrrrrrrrrrrrr', parentId: 2, level: 2, order: 1 },
  { id: 5, label: 'Promocje 4', url: '#ttttttttttttt', parentId: 2, level: 2, order: 0 },
  { id: 6, label: 'Promocje 5', url: '#yyyyyyyyyyyy', parentId: 5, level: 2, order: 2 },
  { id: 7, label: 'Promocje 6', url: '#uuuuuuuuuuuuu', parentId: 5, level: 2, order: 3 },
  { id: 8, label: 'Promocje 7', url: '#iiiiiiiiii', parentId: 7, level: 3, order: 1 },
  { id: 9, label: 'Promocje 8', url: '#oooooooooo', parentId: 7, level: 3, order: 0 },
  { id: 10, label: 'Ostatnie 7 dni', url: '#ppppppppppp', parentId: null, level: 0, order: 1 },
  { id: 11, label: 'Najlepsze 1', url: '#jjjjjjjjjjjj', parentId: 10, level: 1, order: 1 },
  { id: 12, label: 'Najlepsze 2', url: '#jjjjjjjjjjj', parentId: 10, level: 1, order: 2 },
  { id: 13, label: 'Najlepsze 3', url: '#jjjjjjjjj', parentId: 10, level: 1, order: 3 },
  { id: 14, label: 'Najlepsze 4', url: '#gggggggggg', parentId: 10, level: 1, order: 0 },
];

const MultiLevelMenu: React.FC = () => {
  const { navigation, setNavigation } = useNavigationStore();

  useEffect(() => {
    const tree = buildTree(initialNavigation);
    setNavigation(tree);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // Pusta tablica, aby efekt uruchomił się tylko raz

  const renderMenu = (items: INavItem[] | undefined, level = 0) => {
    if (!Array.isArray(items)) return null;

    return (
      <ul className={level === 0 ? 'menu' : 'menu-dropdown'}>
        {items.map((item) => (
          <li
            key={`${item.id}_menu-item`}
            className={classNames('item', {
              horizonatal: level === 0 && item.children && item.children?.length > 0,
              vertical: level > 0 && item.children && item.children?.length > 0,
            })}
          >
            <div className="item-content">
              <span>{item.label}</span>
              {item.children && item.children?.length > 0 && <CaretIcon />}
            </div>
            {item.children && item.children?.length > 0 && renderMenu(item.children, level + 1)}
          </li>
        ))}
      </ul>
    );
  };

  return navigation?.length > 0 && <nav className="nav-menu">{renderMenu(navigation)}</nav>;
};

export default memo(MultiLevelMenu);

src\app\shared\components\Collapse.tsx
import React, { useEffect, useState } from 'react';
import { motion } from 'framer-motion';

interface IPadding {
  paddingTop?: number | null;
  paddingRight?: number | null;
  paddingBottom?: number | null;
  paddingLeft?: number | null;
}

interface ICollapseProps {
  isOpen: boolean;
  children: React.ReactNode;
  duration?: number;
  ease?: 'easeInOut' | 'easeIn' | 'easeOut' | 'linear';
  padding?: IPadding | null;
}

const paddingDefault: IPadding = {
  paddingTop: 16,
  paddingRight: 24,
  paddingBottom: 16,
  paddingLeft: 24,
};

const Collapse: React.FC<ICollapseProps> = ({ isOpen, children, duration = 0.35, ease = 'easeInOut', padding = {} }) => {
  const [paddings, setPaddings] = useState<IPadding | null>(paddingDefault);
  const { paddingTop, paddingRight, paddingBottom, paddingLeft } = paddings || {};

  useEffect(() => {
    setPaddings(() => ({ ...paddingDefault, ...padding }));
  }, [padding, isOpen]);

  return (
    <motion.div
      initial={false}
      animate={{
        height: isOpen ? 'auto' : 0,
        opacity: isOpen ? 1 : 0,
        scale: isOpen ? 1 : 0.95,
        paddingLeft: isOpen ? `${paddingLeft ?? 0}px` : '0',
        paddingRight: isOpen ? `${paddingRight ?? 0}px` : '0',
        paddingTop: isOpen ? `${paddingTop ?? 0}px` : '0',
        paddingBottom: isOpen ? `${paddingBottom ?? 0}px` : '0',
      }}
      style={{ overflow: 'hidden' }}
      className="bg-secondary block"
      transition={{
        duration,
        ease,
      }}
    >
      {children}
    </motion.div>
  );
};

export default Collapse;

src\app\shared\components\button\Button.tsx
import React, { MouseEventHandler } from 'react';
import classNames from 'classnames';

export type TypeButton = 'button' | 'submit' | 'reset';
export type IButtonVariantTypes = 'primary' | 'secondary' | 'tertiary';

export enum ButtonVariant {
  PRIMARY = 'primary',
  SECONDARY = 'secondary',
  TERTIARY = 'tertiary',
}

interface ButtonProps {
  id?: string;
  type?: TypeButton;
  children: React.ReactNode;
  handleClick?: MouseEventHandler<HTMLButtonElement>;
  disabled?: boolean;
  round?: boolean;
  className?: string;
  ariaLabel?: string;
  variant?: IButtonVariantTypes;
}

const Button: React.FC<ButtonProps> = ({
  id,
  type = 'button',
  children,
  handleClick,
  disabled = false,
  round = false,
  className,
  ariaLabel,
  variant = 'primary',
}) => {
  const baseClasses = 'button-component transition flex items-center justify-center text-sm font-semibold shadow-blue-500/50';

  const activeVariant = (variant: IButtonVariantTypes): string => {
    switch (variant) {
      case 'secondary':
        return 'button-secondary hover:opacity-60';
      case 'tertiary':
        return 'button-tertiary hover:opacity-60';
      default:
        return 'button-primary hover:opacity-80';
    }
  };

  const buttonClassNames = classNames(
    baseClasses,
    !round ? activeVariant(variant as IButtonVariantTypes) : '',
    {
      'bg-transparent rounded-full p-0 hover:bg-white hover:color-primary hover:opacity-80': round,
      'rounded-lg p-3.5 py-2.5 border border-solid': !round,
    },
    className
  );

  return (
    <button id={id} type={type} onClick={handleClick} disabled={disabled} aria-label={ariaLabel} className={buttonClassNames}>
      {children}
    </button>
  );
};

export default Button;

src\app\shared\components\formElements\FormElements.model.tsx
import { IFormElementsTypes } from './FormElements.type';
import { IInput } from '../input/input.model';

export interface IFormElementsConfig {
  [name: string]: IFormElements;
}

export type IFormElements = Omit<IInput, 'type'> & {
  config?: IFormElements;
  header?: string;
  isHeader?: boolean;
  iconComponent?: JSX.Element;
  disabled?: boolean;
  formCellType?: IFormElementsTypes;
  value?: string | number | string[] | number[];
  type?: IFormElementsTypes;
  hidden?: boolean;
  styleClass?: string;
  prefix?: string;
  placeholder?: string;
  name?: string;
  max?: number;
  min?: number;
  step?: number;
};

export const FormCellConfigDefault = (): IFormElements => ({
  step: 1,
  type: 'text',
});

src\app\shared\components\formElements\FormElements.tsx
import React, { useMemo } from 'react';
import { IFormElements } from './FormElements.model';
import { Controller, useFormContext } from 'react-hook-form';
import Input from '@/shared/components/input/Input';
import { InputType, InputTypes } from '../input/input.types';
import { IFormElementsTypes } from './FormElements.type';

interface IProps {
  formControlName: string;
  config: IFormElements;
}

const { INPUT_TEXT, INPUT_NUMBER, INPUT_SEARCH } = InputType;

const FormElements = ({ formControlName, config }: IProps) => {
  const { control, formState } = useFormContext();
  const { errors } = formState || {};
  const { formCellType } = config || {};

  const renderFormElement = useMemo(() => {
    const inputType = (cellType: IFormElementsTypes): InputTypes => {
      if (cellType === INPUT_NUMBER) {
        return 'input-number';
      } else if (cellType === INPUT_SEARCH) {
        return 'search';
      }
      return 'text';
    };

    switch (formCellType) {
      case INPUT_TEXT:
      case INPUT_NUMBER:
      case INPUT_SEARCH:
        return (
          <Controller
            name={formControlName}
            control={control}
            render={({ field }) => (
              <Input {...field} config={{ ...config, type: inputType(formCellType) }} error={errors[formControlName]?.message as string} />
            )}
          />
        );
      default:
        return null;
    }
  }, [formControlName, control, config, errors, formCellType]);

  return (
    <div className={`form-element ${config.styleClass || ''}`}>
      {config.header && (
        <label className="text-secondary text-sm" htmlFor={formControlName}>
          {config.header}
        </label>
      )}
      {renderFormElement}
    </div>
  );
};

export default FormElements;

src\app\shared\components\formElements\FormElements.type.tsx
export type IFormElementsTypes =
  | 'text'
  | 'input-text'
  | 'input-number'
  | 'input-range'
  | 'input-switch'
  | 'input-search'
  | 'select'
  | 'checkbox';

src\app\shared\components\icons\CaretIcon.tsx
import classNames from 'classnames';

const CaretIcon: React.FC = () => {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" className={classNames('w-4 h-4 ml-5')}>
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 5l7 7-7 7" />
    </svg>
  );
};

export default CaretIcon;

src\app\shared\components\icons\DragIcon.tsx
const DragIcon: React.FC = () => {
  return (
    <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
      <g clipPath="url(#clip0_2090_384)">
        <path
          d="M4.16667 7.50002L1.66667 10M1.66667 10L4.16667 12.5M1.66667 10H18.3333M7.5 4.16669L10 1.66669M10 1.66669L12.5 4.16669M10 1.66669V18.3334M12.5 15.8334L10 18.3334M10 18.3334L7.5 15.8334M15.8333 7.50002L18.3333 10M18.3333 10L15.8333 12.5"
          stroke="#475467"
          strokeWidth="1.66667"
          strokeLinecap="round"
          strokeLinejoin="round"
        />
      </g>
      <defs>
        <clipPath id="clip0_2090_384">
          <rect width="20" height="20" fill="white" />
        </clipPath>
      </defs>
    </svg>
  );
};

export default DragIcon;

src\app\shared\components\icons\PlusIcon.tsx
const PlusIcon: React.FC = () => {
  return (
    <svg width="19" height="20" viewBox="0 0 19 20" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path
        d="M9.50002 6.66667V13.3333M6.16669 10H12.8334M17.8334 10C17.8334 14.6024 14.1024 18.3333 9.50002 18.3333C4.89765 18.3333 1.16669 14.6024 1.16669 10C1.16669 5.39763 4.89765 1.66667 9.50002 1.66667C14.1024 1.66667 17.8334 5.39763 17.8334 10Z"
        stroke="currentColor"
        strokeWidth="1.66667"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
};

export default PlusIcon;

src\app\shared\components\icons\SearchIcon.tsx
const SearchIcon: React.FC = () => {
  return (
    <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path
        d="M17.5 17.5L14.5834 14.5833M16.6667 9.58333C16.6667 13.4954 13.4954 16.6667 9.58333 16.6667C5.67132 16.6667 2.5 13.4954 2.5 9.58333C2.5 5.67132 5.67132 2.5 9.58333 2.5C13.4954 2.5 16.6667 5.67132 16.6667 9.58333Z"
        stroke="#667085"
        strokeWidth="1.66667"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
};

export default SearchIcon;

src\app\shared\components\icons\TrashIcon.tsx
const TrashIcon: React.FC = () => {
  return (
    <svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path
        d="M17.5 12.5H22.5M12.5 15H27.5M25.8333 15L25.2489 23.7661C25.1612 25.0813 25.1174 25.7389 24.8333 26.2375C24.5833 26.6765 24.206 27.0294 23.7514 27.2497C23.235 27.5 22.5759 27.5 21.2578 27.5H18.7422C17.4241 27.5 16.765 27.5 16.2486 27.2497C15.794 27.0294 15.4167 26.6765 15.1667 26.2375C14.8826 25.7389 14.8388 25.0813 14.7511 23.7661L14.1667 15M18.3333 18.75V22.9167M21.6667 18.75V22.9167"
        stroke="currentColor"
        strokeWidth="1.66667"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
};

export default TrashIcon;

src\app\shared\components\input\input.model.tsx
import { InputTypes } from './input.types';

export interface IInput {
  type?: InputTypes;
  placeholder?: string;
  min?: number;
  max?: number;
  step?: number;
  disabled?: boolean;
}

export const inputConfigDefault = (): IInput => ({
  placeholder: '',
  step: 1,
  type: 'text',
});

src\app\shared\components\input\Input.tsx
import React from 'react';
import { IInput } from './input.model';
import SearchIcon from '../icons/SearchIcon';
import classNames from 'classnames';
import Button from '../button/Button';
import TrashIcon from '../icons/TrashIcon';

interface IProps {
  name: string;
  config: IInput;
  value?: string | number;
  onChange?: (value: string | number) => void;
  error?: string | null | undefined;
  touched?: boolean;
}

const Input: React.FC<IProps> = ({ name, config, value, onChange, error }) => {
  const { type, placeholder, disabled, min, max, step } = config;

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onChange?.(e.target.value);
  };

  const handleClear = () => {
    onChange?.('');
  };

  const inputClasses = classNames(
    'block w-full py-2 px-3 text-base border border-input border-solid rounded-lg transition-all focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 relative',
    {
      'pl-[32px] [&::-webkit-search-cancel-button]:hidden': type === 'search',
      'border-red-500 focus:ring-red-500 focus:border-red-500': error && !disabled,
      'active:border-blue-500 active:ring-1 active:ring-blue-500': !error && !disabled, // Active state
      'cursor-not-allowed bg-gray-100': disabled,
    }
  );

  return (
    <div className="block">
      <div className="relative flex flex-col rounded-lg border-0">
        {type === 'search' && (
          <div className="pointer-events-none absolute inset-y-0 start-0 z-10 flex items-center ps-3">
            <SearchIcon />
          </div>
        )}

        <input
          id={name}
          name={name}
          type={type || 'text'}
          placeholder={placeholder || ''}
          value={value ?? ''}
          min={min}
          max={max}
          step={step}
          disabled={disabled}
          onChange={handleChange}
          className={inputClasses}
          style={{ '--tw-placeholder-color': 'var(--text-placeholder)' } as React.CSSProperties}
          aria-invalid={!!error}
          autoComplete="off"
        />

        {type === 'search' && value !== '' && (
          <Button handleClick={handleClear} round={true} className={classNames('absolute end-2')}>
            <TrashIcon />
          </Button>
        )}
      </div>

      {error && <span className="text-xs text-red-500">{error}</span>}
    </div>
  );
};

export default Input;

src\app\shared\components\input\input.types.tsx
export type InputTypes = 'text' | 'input-text' | 'input-number' | 'input-search' | 'search';

export enum InputType {
  INPUT_TEXT = 'input-text',
  INPUT_NUMBER = 'input-number',
  INPUT_SEARCH = 'input-search',
}

src\app\shared\helpers\form-config.tsx
import { IFormElementsConfig, IFormElements } from '@/shared/components/formElements/FormElements.model';
import { InputType } from '@/shared/components/input/input.types';

export const createConfigForm = (formConfig: IFormElementsConfig, params: { prefix?: string } = {}): IFormElements[] => {
  return Object.entries(formConfig).map(([name, config]) => {
    const { prefix } = params;
    const { formCellType } = (config as IFormElements) || {};
    const mergedConfig = {
      ...config,
      formControlName: name,
      formCellType: formCellType ?? InputType.INPUT_TEXT,
      header: config.header ?? `${prefix}.${name}`,
      placeholder: config.placeholder ?? `${prefix}.${name}`,
    };
    return mergedConfig;
  });
};

src\app\shared\helpers\tree\index.ts
export * from './structure';
export * from './operations';
export * from './navigation';
export * from './utils';

src\app\shared\helpers\tree\navigation.spec.ts
import { INavItem } from '@/src/app/store/navigationStore';
import { findMaxId, findParentById } from './navigation';

describe('findParentById', () => {
  it('should find the parent of a direct child', () => {
    const items: INavItem[] = [
      {
        id: 1,
        parentId: null,
        label: 'Root',
        children: [{ id: 2, parentId: 1, label: 'Child', children: [], level: 1, order: 0 }],
        level: 0,
        order: 0,
      },
    ];
    const result = findParentById(items, 2);
    expect(result).toEqual({
      id: 1,
      parentId: null,
      label: 'Root',
      level: 0,
      order: 0,
      children: [{ id: 2, parentId: 1, label: 'Child', children: [], level: 1, order: 0 }],
    });
  });

  it('should find the parent of a nested child', () => {
    const items: INavItem[] = [
      {
        id: 1,
        parentId: null,
        label: 'Root',
        children: [
          {
            id: 2,
            parentId: 1,
            label: 'Child',
            children: [{ id: 3, parentId: 2, label: 'Grandchild', children: [], level: 2, order: 0 }],
            level: 1,
            order: 0,
          },
        ],
        level: 0,
        order: 0,
      },
    ];
    const result = findParentById(items, 3);
    expect(result).toEqual({
      id: 2,
      parentId: 1,
      label: 'Child',
      children: [{ id: 3, parentId: 2, label: 'Grandchild', children: [], level: 2, order: 0 }],
      level: 1,
      order: 0,
    });
  });

  it('should return undefined if the parentId does not exist', () => {
    const items: INavItem[] = [{ id: 1, parentId: null, label: 'Root', children: [], level: 0, order: 0 }];
    const result = findParentById(items, 999);
    expect(result).toBeUndefined();
  });

  it('should return undefined if the tree is empty', () => {
    const items: INavItem[] = [];
    const result = findParentById(items, 1);
    expect(result).toBeUndefined();
  });
});

describe('findMaxId', () => {
  it('should return 0 for an empty tree', () => {
    const result = findMaxId([]);
    expect(result).toBe(0);
  });

  it('should return the max id for a flat list', () => {
    const items = [{ id: 1 }, { id: 3 }, { id: 2 }];
    const result = findMaxId(items);
    expect(result).toBe(3);
  });

  it('should return the max id in a nested tree', () => {
    const items = [
      { id: 1, children: [{ id: 3 }, { id: 2 }] },
      { id: 4, children: [{ id: 7 }, { id: 5, children: [{ id: 6 }] }] },
    ];
    const result = findMaxId(items);
    expect(result).toBe(7);
  });
});

src\app\shared\helpers\tree\navigation.ts
import { IFlattenedItem } from '@/src/app/components/builder-menu/MenuEditor.model';
import { INavItem } from '@/src/app/store/navigationStore';
import { UniqueIdentifier } from '@dnd-kit/core';
import { arrayMove } from '@dnd-kit/sortable';
import { traverseTree } from './utils';

export const getDragDepth = (offset: number, indentationWidth: number): number => {
  return Math.round(offset / indentationWidth);
};

export const getMaxDepth = ({ previousItem }: { previousItem: IFlattenedItem }) => {
  if (previousItem) return previousItem.level + 1;
  return 0;
};

export const getMinDepth = ({ nextItem }: { nextItem: IFlattenedItem }) => {
  if (nextItem) return nextItem.level;
  return 0;
};

const countChildren = (items: INavItem[], count = 0): number => {
  return items.reduce((acc, { children }) => {
    if (children?.length) return countChildren(children, acc + 1);
    return acc + 1;
  }, count);
};

export const childrenCount = (items: INavItem[], id: UniqueIdentifier | null) => {
  const item = findItemDeep(items, id!);
  return item ? countChildren(item?.children ?? []) : 0;
};

export const childrensItems = (items: INavItem[], id: UniqueIdentifier) => {
  const item = findItemDeep(items, id);
  return item ? item.children : [];
};

export const findItemDeep = (items: INavItem[], id: string | number): INavItem | undefined => traverseTree(items, (item) => item.id === id);

export const findMaxId = (items: INavItem[]): number => {
  let maxId = 0;
  items.forEach((item) => {
    if (typeof item.id === 'number') maxId = Math.max(maxId, item?.id);
    if (item?.children && item?.children?.length) maxId = Math.max(maxId, findMaxId(item?.children));
  });
  return maxId;
};

export const findParentById = (items: INavItem[], childId: string | number): INavItem | undefined => {
  for (const item of items) {
    if (item.children?.some((child) => child.id === childId)) {
      return item;
    }
    if (item.children) {
      const found = findParentById(item.children, childId);
      if (found) return found;
    }
  }
  return undefined;
};

export const levelProjection = (
  items: IFlattenedItem[],
  activeId: UniqueIdentifier,
  overId: UniqueIdentifier,
  dragOffset: number,
  indentationWidth: number
) => {
  const overItemIndex = items.findIndex(({ id }) => id === overId);
  const activeItemIndex = items.findIndex(({ id }) => id === activeId);
  const activeItem = items[activeItemIndex];
  const newItems = arrayMove(items, activeItemIndex, overItemIndex);
  const previousItem = newItems[overItemIndex - 1];
  const nextItem = newItems[overItemIndex + 1];
  const dragLevel = getDragDepth(dragOffset, indentationWidth);
  const projectedDepth = activeItem.level + dragLevel;
  const maxDepth = getMaxDepth({
    previousItem,
  });

  const minDepth = getMinDepth({ nextItem });
  let level = projectedDepth;
  if (projectedDepth >= maxDepth) {
    level = maxDepth;
  } else if (projectedDepth < minDepth) {
    level = minDepth;
  }

  const getParentId = (): string | number | null => {
    if (level === 0 || !previousItem) return null;
    if (level === previousItem.level) return previousItem.parentId;
    if (level > previousItem.level) return previousItem.id;

    const newParent = newItems
      .slice(0, overItemIndex)
      .reverse()
      .find((item) => item.level === level)?.parentId;
    return newParent ?? null;
  };
  return { level, maxDepth, minDepth, parentId: getParentId() };
};

src\app\shared\helpers\tree\operations.spec.ts
import { INavItem } from '@/src/app/store/navigationStore';
import { addItem, deleteItem, updateItem } from './operations';

describe('addItem', () => {
  it('should add an item as a child of a nested element', () => {
    const items: INavItem[] = [
      {
        id: 1,
        parentId: null,
        label: 'Root',
        children: [{ id: 2, parentId: 1, label: 'Child', children: [], level: 1, order: 0 }],
        level: 0,
        order: 0,
      },
    ];
    const newItem: INavItem = { id: 3, parentId: 2, label: 'Grandchild', children: [] };
    const result = addItem(items, newItem, 2);
    expect(result).toEqual([
      {
        id: 1,
        parentId: null,
        label: 'Root',
        children: [
          {
            id: 2,
            parentId: 1,
            label: 'Child',
            children: [{ id: 3, parentId: 2, label: 'Grandchild', children: [], level: 2, order: 0 }],
            level: 1,
            order: 0,
          },
        ],
        level: 0,
        order: 0,
      },
    ]);
  });

  it('should throw an error if parentId does not exist in a nested tree', () => {
    const items: INavItem[] = [{ id: 1, parentId: null, label: 'Root', children: [], level: 0, order: 0 }];
    const newItem: INavItem = { id: 2, parentId: 999, label: 'Invalid Parent', children: [] };
    expect(() => addItem(items, newItem, 999)).toThrow('Parent with id 999 does not exist.');
  });
});

describe('updateItem', () => {
  it('should update the label of a root item', () => {
    const items: INavItem[] = [{ id: 1, parentId: null, label: 'Root', children: [], level: 0, order: 0 }];
    const updatedFields = { label: 'Updated Root' };
    const result = updateItem(items, 1, updatedFields);
    expect(result).toEqual([{ id: 1, parentId: null, label: 'Updated Root', children: [], level: 0, order: 0 }]);
  });

  it('should update the label of a child item', () => {
    const items: INavItem[] = [
      {
        id: 1,
        parentId: null,
        label: 'Root',
        children: [{ id: 2, parentId: 1, label: 'Child', children: [], level: 1, order: 0 }],
        level: 0,
        order: 0,
      },
    ];
    const updatedFields = { label: 'Updated Child' };
    const result = updateItem(items, 2, updatedFields);
    expect(result).toEqual([
      {
        id: 1,
        parentId: null,
        label: 'Root',
        children: [{ id: 2, parentId: 1, label: 'Updated Child', children: [], level: 1, order: 0 }],
        level: 0,
        order: 0,
      },
    ]);
  });

  it('should do nothing if the item does not exist', () => {
    const items: INavItem[] = [{ id: 1, parentId: null, label: 'Root', children: [], level: 0, order: 0 }];
    const updatedFields = { label: 'Non-existent' };
    const result = updateItem(items, 999, updatedFields);
    expect(result).toEqual(items);
  });
});

describe('deleteItem', () => {
  it('should delete an item with no children', () => {
    const items: INavItem[] = [{ id: 1, parentId: null, label: 'Root', children: [], level: 0, order: 0 }];
    const result = deleteItem(items, 1);
    expect(result).toEqual([]);
  });

  it('should delete an item and its children', () => {
    const items: INavItem[] = [
      {
        id: 1,
        parentId: null,
        label: 'Root',
        children: [{ id: 2, parentId: 1, label: 'Child', children: [], level: 1, order: 0 }],
        level: 0,
        order: 0,
      },
    ];
    const result = deleteItem(items, 1);
    expect(result).toEqual([]);
  });

  it('should delete a child item and leave the parent intact', () => {
    const items: INavItem[] = [
      {
        id: 1,
        parentId: null,
        label: 'Root',
        children: [{ id: 2, parentId: 1, label: 'Child', children: [], level: 1, order: 0 }],
        level: 0,
        order: 0,
      },
    ];
    const result = deleteItem(items, 2);
    expect(result).toEqual([
      {
        id: 1,
        parentId: null,
        label: 'Root',
        children: [],
        level: 0,
        order: 0,
      },
    ]);
  });

  it('should do nothing if the item does not exist', () => {
    const items: INavItem[] = [{ id: 1, parentId: null, label: 'Root', children: [], level: 0, order: 0 }];
    const result = deleteItem(items, 999);
    expect(result).toEqual(items);
  });
});

src\app\shared\helpers\tree\operations.ts
import { INavItem } from '@/store/navigationStore';
import { traverseTree } from './utils';

export const addItem = (items: INavItem[], newItem: INavItem, parentId: string | number | null): INavItem[] => {
  const clone = [...items];

  if (parentId !== null) {
    const parent = traverseTree(clone, (node) => node.id === parentId);
    if (!parent) {
      throw new Error(`Parent with id ${parentId} does not exist.`);
    }
    parent.children = [...(parent.children || []), { ...newItem, level: (parent.level || 0) + 1, order: parent.children?.length || 0 }];
    return clone;
  }

  return [...clone, { ...newItem, level: 0, order: clone.length }];
};

export const deleteItem = (items: INavItem[], id: string | number | null): INavItem[] => {
  if (!id) return items;
  return (
    items
      ?.filter((item) => item.id !== id)
      ?.map((item) => ({
        ...item,
        children: deleteItem(item?.children || [], id),
      })) ?? []
  );
};

export const updateItem = (items: INavItem[], id: string | number | null, updatedFields: Partial<Omit<INavItem, 'id'>>): INavItem[] => {
  return (
    items?.map((item) => {
      if (item?.id === id) {
        return {
          ...item,
          ...updatedFields,
        };
      }
      return {
        ...item,
        children: updateItem(item?.children || [], id, updatedFields),
      };
    }) ?? []
  );
};

src\app\shared\helpers\tree\structure.spec.ts
import { INavItem } from '@/src/app/store/navigationStore';
import {
  adjustTranslate,
  buildTree,
  buildTreeFromFlatten,
  findIdPushChildren,
  flattenTree,
  removeChildrenOf,
  updateOrderAndLevel,
} from './structure';
import { IFlattenedItem } from '@/src/app/components/builder-menu/MenuEditor.model';
import { Modifier } from '@dnd-kit/core';

describe('buildTree', () => {
  it('should return an empty array for an empty input', () => {
    expect(buildTree([])).toEqual([]);
  });

  it('should build a tree with a single root element', () => {
    const items = [{ id: 1, parentId: null, label: 'Root' }];
    const result = buildTree(items);
    expect(result).toEqual([{ id: 1, parentId: null, label: 'Root', children: [] }]);
  });

  it('should build a tree with nested elements', () => {
    const items = [
      { id: 1, parentId: null, label: 'Root' },
      { id: 2, parentId: 1, label: 'Child' },
    ];
    const result = buildTree(items);
    expect(result).toEqual([
      {
        id: 1,
        parentId: null,
        label: 'Root',
        children: [{ id: 2, parentId: 1, label: 'Child', children: [] }],
      },
    ]);
  });

  it('should handle multiple levels of nesting', () => {
    const items = [
      { id: 1, parentId: null, label: 'Root' },
      { id: 2, parentId: 1, label: 'Child 1' },
      { id: 3, parentId: 2, label: 'Child 2' },
    ];
    const result = buildTree(items);
    expect(result).toEqual([
      {
        id: 1,
        parentId: null,
        label: 'Root',
        children: [
          {
            id: 2,
            parentId: 1,
            label: 'Child 1',
            children: [{ id: 3, parentId: 2, label: 'Child 2', children: [] }],
          },
        ],
      },
    ]);
  });

  it('should ignore items with missing or invalid parentId', () => {
    const items = [
      { id: 1, parentId: null, label: 'Root' },
      { id: 2, parentId: 999, label: 'Orphan' },
    ];
    const result = buildTree(items);
    expect(result).toEqual([{ id: 1, parentId: null, label: 'Root', children: [] }]);
  });
});

describe('flattenTree', () => {
  it('should flatten a tree with a single root element', () => {
    const items: INavItem[] = [{ id: 1, parentId: null, label: 'Root', children: [], level: 0, order: 0 }];
    const result = flattenTree(items);
    expect(result).toEqual([{ id: 1, parentId: null, label: 'Root', level: 0, order: 0, children: [] }]);
  });

  it('should flatten a tree with nested elements', () => {
    const items: INavItem[] = [
      {
        id: 1,
        parentId: null,
        label: 'Root',
        children: [{ id: 2, parentId: 1, label: 'Child', children: [], level: 1, order: 0 }],
        level: 0,
        order: 0,
      },
    ];
    const result = flattenTree(items);
    expect(result).toEqual([
      {
        id: 1,
        parentId: null,
        label: 'Root',
        level: 0,
        order: 0,
        children: [{ id: 2, parentId: 1, label: 'Child', children: [], level: 1, order: 0 }],
      },
      { id: 2, parentId: 1, label: 'Child', level: 1, order: 0, children: [] },
    ]);
  });

  it('should flatten a tree with multiple levels', () => {
    const items: INavItem[] = [
      {
        id: 1,
        parentId: null,
        label: 'Root',
        children: [
          {
            id: 2,
            parentId: 1,
            label: 'Child 1',
            children: [{ id: 3, parentId: 2, label: 'Child 2', children: [], level: 2, order: 0 }],
            level: 1,
            order: 0,
          },
        ],
        level: 0,
        order: 0,
      },
    ];
    const result = flattenTree(items);
    expect(result).toEqual([
      {
        id: 1,
        parentId: null,
        label: 'Root',
        level: 0,
        order: 0,
        children: [
          {
            id: 2,
            parentId: 1,
            label: 'Child 1',
            children: [{ id: 3, parentId: 2, label: 'Child 2', children: [], level: 2, order: 0 }],
            level: 1,
            order: 0,
          },
        ],
      },
      {
        id: 2,
        parentId: 1,
        label: 'Child 1',
        level: 1,
        order: 0,
        children: [{ id: 3, parentId: 2, label: 'Child 2', children: [], level: 2, order: 0 }],
      },
      { id: 3, parentId: 2, label: 'Child 2', level: 2, order: 0, children: [] },
    ]);
  });
});

describe('removeChildrenOf', () => {
  it('should remove all children of a given parentId', () => {
    const items: IFlattenedItem[] = [
      {
        id: 1,
        label: 'Promocje',
        parentId: null,
        level: 0,
        order: 0,
      },
      {
        id: 2,
        label: 'Promocje 1',
        parentId: 1,
        level: 1,
        order: 0,
      },
      {
        id: 4,
        label: 'Promocje 3',
        parentId: 2,
        level: 2,
        order: 0,
      },
      {
        id: 5,
        label: 'Promocje 4',
        parentId: 2,
        level: 2,
        order: 1,
      },
    ];
    const result = removeChildrenOf(items, [])[1];
    expect(result).toEqual({ id: 2, parentId: 1, label: 'Promocje 1', level: 1, order: 0 });
  });

  it('should handle empty input gracefully', () => {
    const items: IFlattenedItem[] = [];
    const result = removeChildrenOf(items, [1]);
    expect(result).toEqual([]);
  });
});

describe('findIdPushChildren', () => {
  it('should add children to a root node', () => {
    const items = [{ id: 1, children: [] }];
    const newChildren = [{ id: 2 }, { id: 3 }];
    const result = findIdPushChildren(1, items, newChildren);
    expect(result).toEqual([{ id: 1, children: [{ id: 2 }, { id: 3 }] }]);
  });

  it('should add children to a nested node', () => {
    const items = [
      {
        id: 1,
        children: [
          {
            id: 2,
            children: [],
          },
        ],
      },
    ];
    const newChildren = [{ id: 3 }];
    const result = findIdPushChildren(2, items, newChildren);
    expect(result).toEqual([
      {
        id: 1,
        children: [
          {
            id: 2,
            children: [{ id: 3 }],
          },
        ],
      },
    ]);
  });

  it('should not modify the tree if the id is not found', () => {
    const items = [{ id: 1, children: [] }];
    const newChildren = [{ id: 2 }];
    const result = findIdPushChildren(999, items, newChildren);
    expect(result).toEqual(items);
  });

  it('should add children to the correct parent', () => {
    const sourceArray: INavItem[] = [
      {
        id: 1,
        parentId: null,
        label: 'Root',
        children: [
          {
            id: 2,
            parentId: 1,
            label: 'Child',
            children: [],
            level: 1,
            order: 0,
          },
        ],
        level: 0,
        order: 0,
      },
    ];
    const newChildren: INavItem[] = [{ id: 3, parentId: 2, label: 'Grandchild', children: [], level: 2, order: 0 }];
    const result = findIdPushChildren(2, sourceArray, newChildren);
    expect(result).toEqual([
      {
        id: 1,
        parentId: null,
        label: 'Root',
        children: [
          {
            id: 2,
            parentId: 1,
            label: 'Child',
            children: [
              {
                id: 3,
                parentId: 2,
                label: 'Grandchild',
                children: [],
                level: 2,
                order: 0,
              },
            ],
            level: 1,
            order: 0,
          },
        ],
        level: 0,
        order: 0,
      },
    ]);
  });
});

describe('buildTreeFromFlatten', () => {
  it('should return an empty array for an empty input', () => {
    const result = buildTreeFromFlatten([]);
    expect(result).toEqual([]);
  });

  it('should build a single-level tree', () => {
    const items = [
      { id: 1, parentId: null, label: 'Root', order: 0, level: 0 },
      { id: 2, parentId: 1, label: 'Child', order: 1, level: 1 },
    ];
    const result = buildTreeFromFlatten(items);
    expect(result).toEqual([
      {
        id: 1,
        parentId: null,
        label: 'Root',
        order: 0,
        level: 0,
        children: [
          {
            id: 2,
            parentId: 1,
            label: 'Child',
            order: 1,
            level: 1,
            children: [],
          },
        ],
      },
    ]);
  });

  it('should handle multiple levels of nesting', () => {
    const items = [
      { id: 1, parentId: null, label: 'Root', order: 0, level: 0 },
      { id: 2, parentId: 1, label: 'Child 1', order: 1, level: 1 },
      { id: 3, parentId: 2, label: 'Child 2', order: 2, level: 2 },
    ];
    const result = buildTreeFromFlatten(items);
    expect(result).toEqual([
      {
        id: 1,
        parentId: null,
        label: 'Root',
        order: 0,
        level: 0,
        children: [
          {
            id: 2,
            parentId: 1,
            label: 'Child 1',
            order: 1,
            level: 1,
            children: [
              {
                id: 3,
                parentId: 2,
                label: 'Child 2',
                order: 2,
                level: 2,
                children: [],
              },
            ],
          },
        ],
      },
    ]);
  });

  it('should throw an error for invalid parent references', () => {
    const items = [
      { id: 1, parentId: null, label: 'Root', order: 0, level: 0 },
      { id: 2, parentId: 999, label: 'Invalid Child', order: 1, level: 1 },
    ];
    expect(() => buildTreeFromFlatten(items)).toThrow('Item with id 999 not found');
  });
});

describe('updateOrderAndLevel', () => {
  it('should update order and level for a single-level tree', () => {
    const items = [
      { id: 1, order: null, level: null, children: [] },
      { id: 2, order: null, level: null, children: [] },
    ];
    const result = updateOrderAndLevel(items);
    expect(result).toEqual([
      { id: 1, order: 0, level: 0, children: [] },
      { id: 2, order: 1, level: 0, children: [] },
    ]);
  });

  it('should update order and level for a multi-level tree', () => {
    const items = [
      {
        id: 1,
        order: null,
        level: null,
        children: [
          { id: 2, order: null, level: null, children: [] },
          { id: 3, order: null, level: null, children: [{ id: 4, order: null, level: null, children: [] }] },
        ],
      },
    ];
    const result = updateOrderAndLevel(items);
    expect(result).toEqual([
      {
        id: 1,
        order: 0,
        level: 0,
        children: [
          { id: 2, order: 0, level: 1, children: [] },
          { id: 3, order: 1, level: 1, children: [{ id: 4, order: 0, level: 2, children: [] }] },
        ],
      },
    ]);
  });

  it('should handle an empty array gracefully', () => {
    const result = updateOrderAndLevel([]);
    expect(result).toEqual([]);
  });

  it('should update levels and orders correctly', () => {
    const items: INavItem[] = [
      {
        id: 1,
        parentId: null,
        label: 'Root',
        level: 0,
        order: 0,
        children: [
          {
            id: 2,
            parentId: 1,
            label: 'Child 1',
            level: 1,
            order: 0,
            children: [{ id: 3, parentId: 2, label: 'Child 2', level: 2, order: 0, children: [] }],
          },
          { id: 4, parentId: 1, label: 'Child 3', level: 1, order: 1, children: [] },
        ],
      },
    ];
    const result = updateOrderAndLevel(items);
    expect(result).toEqual([
      {
        id: 1,
        parentId: null,
        label: 'Root',
        level: 0,
        order: 0,
        children: [
          {
            id: 2,
            parentId: 1,
            label: 'Child 1',
            level: 1,
            order: 0,
            children: [{ id: 3, parentId: 2, label: 'Child 2', level: 2, order: 0, children: [] }],
          },
          { id: 4, parentId: 1, label: 'Child 3', level: 1, order: 1, children: [] },
        ],
      },
    ]);
  });
});

describe('adjustTranslate', () => {
  it('should return the same transform values', () => {
    const input: Parameters<Modifier>[0] = {
      transform: { x: 10, y: 20, scaleX: 1, scaleY: 1 },
      activatorEvent: null,
      active: null,
      activeNodeRect: null,
      draggingNodeRect: null,
      containerNodeRect: null,
      over: null,
      overlayNodeRect: null,
      scrollableAncestorRects: [],
      scrollableAncestors: [], // Dodano brakujące pole
      windowRect: null,
    };

    const result = adjustTranslate(input);
    expect(result).toEqual(input.transform);
  });
});

src\app\shared\helpers\tree\structure.ts
import { INavItem } from '@/src/app/store/navigationStore';
import { IFlattenedItem } from '@/src/app/components/builder-menu/MenuEditor.model';
import { Modifier, UniqueIdentifier } from '@dnd-kit/core';
import { groupByParent } from './utils';

export const buildTree = (items: INavItem[]): INavItem[] => {
  const groupedItems = groupByParent(items);

  const build = (parentId: string | number | null): INavItem[] =>
    (groupedItems.get(parentId) || [])?.map((item) => ({
      ...item,
      children: build(item.id),
    })) ?? [];

  return build(null);
};

export const buildTreeFromFlatten = (flattenedItems: IFlattenedItem[]): INavItem[] => {
  const root: INavItem = { id: 'root', children: [], label: 'root' };
  const nodes: Record<string, INavItem> = { [root.id]: root };
  const items = flattenedItems?.map((item) => ({ ...item, children: [] })) ?? [];
  for (const item of items) {
    const { id, children, label } = item;
    const parentId = item?.parentId ?? root?.id;
    const parent = nodes[parentId] ?? findItem(items, parentId);
    if (!parent) {
      throw new Error(`Parent with id ${parentId} not found`);
    }
    if (!parent.children) {
      parent.children = [];
    }
    nodes[id] = { id, children, label };
    parent.children.push(item);
  }
  return root.children ?? [];
};

export const findIdPushChildren = (findId: number | string, sourceArray: INavItem[], copyChildren: INavItem[]): INavItem[] => {
  const recursiveSearch = (items: INavItem[]): boolean => {
    for (const item of items) {
      if (item?.id === findId) {
        item.children = [...copyChildren];
        return true;
      }
      if (item?.children && item?.children?.length > 0) {
        const found = recursiveSearch(item.children);
        if (found) return true;
      }
    }
    return false;
  };
  recursiveSearch(sourceArray);
  return sourceArray;
};

export const findItem = (items: INavItem[], itemId: UniqueIdentifier): INavItem => {
  const item = items.find(({ id }) => id === itemId);
  if (!item) throw new Error(`Item with id ${itemId} not found`);
  return item;
};

export const updateOrderAndLevel = (items: INavItem[], currentLevel: number = 0): INavItem[] => {
  return items.map((item, index) => {
    const updatedItem: INavItem = {
      ...item,
      order: index,
      level: currentLevel,
      children: item.children ? updateOrderAndLevel(item.children, currentLevel + 1) : [],
    };
    return updatedItem;
  });
};

export const flattenTree = (items: INavItem[]): IFlattenedItem[] => {
  const result: IFlattenedItem[] = [];
  const traverse = (nodes: INavItem[], parentId: string | number | null = null, level = 0): void => {
    nodes?.forEach((node, index) => {
      result.push({
        ...node,
        id: node.id,
        label: node.label,
        parentId: parentId,
        level: level,
        order: index,
      });
      if (node.children?.length) traverse(node.children, node.id, level + 1);
    });
  };
  traverse(items);
  return result;
};

export const removeChildrenOf = (items: IFlattenedItem[], ids: (string | number)[]): IFlattenedItem[] => {
  const excludeParentIds = [...ids];
  return items?.filter((item) => {
    if (item.parentId && excludeParentIds.includes(item.parentId)) {
      return false;
    }
    return true;
  });
};

export const adjustTranslate: Modifier = ({ transform }) => {
  return {
    ...transform,
  };
};

src\app\shared\helpers\tree\utils.spec.ts
import { groupByParent, traverseTree } from './utils';

interface TreeNode {
  id: number;
  parentId?: number | null;
  children?: TreeNode[];
}

describe('traverseTree', () => {
  it('should find an element at the root level', () => {
    const items: TreeNode[] = [
      { id: 1, children: [] },
      { id: 2, children: [] },
    ];
    const result = traverseTree(items, (node) => node.id === 1);
    expect(result).toEqual({ id: 1, children: [] });
  });

  it('should find an element at a nested level', () => {
    const items: TreeNode[] = [
      { id: 1, children: [{ id: 2, children: [] }] },
      { id: 3, children: [] },
    ];
    const result = traverseTree(items, (node) => node.id === 2);
    expect(result).toEqual({ id: 2, children: [] });
  });

  it('should return undefined if element does not exist', () => {
    const items: TreeNode[] = [
      { id: 1, children: [{ id: 2, children: [] }] },
      { id: 3, children: [] },
    ];
    const result = traverseTree(items, (node) => node.id === 999);
    expect(result).toBeUndefined();
  });

  it('should handle empty input gracefully', () => {
    const result = traverseTree<TreeNode>([], (node) => node.id === 1);
    expect(result).toBeUndefined();
  });
});

describe('groupByParent', () => {
  it('should group items by parentId', () => {
    const items: TreeNode[] = [
      { id: 1, parentId: null },
      { id: 2, parentId: 1 },
      { id: 3, parentId: 1 },
    ];
    const result = groupByParent(items);
    expect(result.get(null)).toEqual([{ id: 1, parentId: null }]);
    expect(result.get(1)).toEqual([
      { id: 2, parentId: 1 },
      { id: 3, parentId: 1 },
    ]);
  });

  it('should return empty map for empty input', () => {
    const result = groupByParent<TreeNode>([]);
    expect(result.size).toBe(0);
  });

  it('should group items with no children', () => {
    const items: TreeNode[] = [{ id: 1, parentId: null }];
    const result = groupByParent(items);
    expect(result.get(null)).toEqual([{ id: 1, parentId: null }]);
    expect(result.get(1)).toBeUndefined();
  });
});

src\app\shared\helpers\tree\utils.ts
export type TreeCallback<T> = (node: T) => boolean;

export const traverseTree = <T extends { children?: T[] }>(items: T[], callback: TreeCallback<T>): T | undefined => {
  for (const node of items) {
    if (callback(node)) return node;
    if (node?.children?.length) {
      const found = traverseTree(node.children, callback);
      if (found) return found;
    }
  }
  return undefined;
};

export const groupByParent = <T extends { parentId?: string | number | null }>(items: T[]): Map<string | number | null, T[]> => {
  return items.reduce((map, item) => {
    const parentId = item.parentId ?? null;
    if (!map.has(parentId)) {
      map.set(parentId, []);
    }
    map.get(parentId)!.push(item);
    return map;
  }, new Map<string | number | null, T[]>());
};

src\app\shared\model\model.tsx
export type IOperationType = 'ADD' | 'EDIT';

src\app\store\navigationStore.ts
import { create } from 'zustand';
import { addItem, deleteItem, findMaxId, flattenTree, updateItem } from '@/shared/helpers/tree';
import { IFlattenedItem } from '../components/builder-menu/MenuEditor.model';

export interface INavItem {
  id: string | number;
  label?: string;
  url?: string;
  parentId?: string | number | null;
  level?: number | null;
  order?: number | null;
  collapsed?: boolean;
  children?: INavItem[];
}

export type INavItemType = INavItem[];

export interface DragState {
  activeId: string | number | null;
  overId: string | number | null;
  offsetLeft: number | null;
}

interface NavigationStore {
  navigation: INavItem[];
  flattenedNavigation: IFlattenedItem[];
  dragState: DragState;
  openCollapseMap: Record<string | number, boolean>;
  setNavigation: (items: INavItem[]) => void;
  addNavItem: (item: Omit<INavItem, 'id'>, parentId?: string | number | null) => void;
  updateNavItem: (id: string | number | null, updatedItem: Omit<INavItem, 'id'>) => void;
  deleteNavItem: (id: string | number | null) => void;
  setDragState: (state: Partial<DragState>) => void;
  resetDragState: () => void;
  toggleCollapse: (id: string | number) => void;
  isCollapseOpen: (id: string | number) => boolean;
}

const useNavigationStore = create<NavigationStore>((set, get) => ({
  navigation: [],
  flattenedNavigation: [],
  dragState: { activeId: null, overId: null, offsetLeft: null },
  openCollapseMap: {},
  setNavigation: (items: INavItem[]) =>
    set(() => {
      const flattened = flattenTree(items);
      return { navigation: items, flattenedNavigation: flattened };
    }),
  addNavItem: (item, parentId = null) =>
    set((state) => {
      const newId = typeof state?.navigation?.[0]?.id === 'string' ? Date.now().toString() : findMaxId(state?.navigation) + 1;
      const newItem: INavItem = {
        id: newId,
        label: item.label ?? '',
        url: item?.url ?? '',
        parentId: parentId ?? null,
        level: 0,
        order: 0,
        children: [],
      };
      const updatedNavigation = addItem(state?.navigation, newItem, parentId);
      return { navigation: updatedNavigation, flattenedNavigation: flattenTree(updatedNavigation) };
    }),
  updateNavItem: (id, updatedItem) =>
    set((state) => {
      const nav = updateItem(state.navigation, id, updatedItem);
      return { navigation: nav, flattenedNavigation: flattenTree(nav) };
    }),
  deleteNavItem: (id) =>
    set((state) => {
      const nav = deleteItem(state.navigation, id);
      return { navigation: nav, flattenedNavigation: flattenTree(nav) };
    }),
  setDragState: (state: Partial<DragState>) =>
    set((current) => ({
      dragState: { ...current.dragState, ...state },
    })),
  resetDragState: () =>
    set(() => ({
      dragState: { activeId: null, overId: null, offsetLeft: null },
    })),
  toggleCollapse: (id: string | number) =>
    set((state) => ({
      openCollapseMap: {
        ...state.openCollapseMap,
        [id]: !state.openCollapseMap[id],
      },
    })),
  isCollapseOpen: (id: string | number) => get().openCollapseMap[id] || false,
}));

export default useNavigationStore;

src\assests\scss\global.scss
@tailwind base;
@tailwind components;
@tailwind utilities;

@import "./variables";
@import "./utility";

body {
  font-feature-settings: normal;
  -moz-osx-font-smoothing: grayscale !important;
  -webkit-font-smoothing: subpixel-antialiased !important;
  overflow-x: hidden;
}

src\assests\scss\_utility.scss
/* SCSS Utility Classes */
.bg-primary {
  background-color: var(--bg-primary);
}

.bg-secondary {
  background-color: var(--bg-secondary);
}

.bg-page {
  background-color: var(--bg-page);
}

.text-primary {
  color: var(--text-primary);
}

.text-secondary {
  color: var(--text-secondary);
}

.text-tertiary {
  color: var(--text-tertiary);
}

.text-placeholder {
  color: var(--text-placeholder);
}

.button-primary {
  background-color: var(--button-primary-bg);
  border-color: var(--button-primary-border);
  color: var(--text-white);
}

.button-secondary {
  color: var(--button-secondary-color);
  border-color: var(--border-primary);
  background-color: var(--bg-primary);
}

.button-tertiary {
  color: var(--button-tertiary-color);
  border-color: var(--button-tertiary-border);
  background-color: var(--bg-primary);
}

.border-primary {
  color: var(--button-secondary-color-fg);
  border-color: var(--border-primary);
}

.border-secondary {
  border-color: var(--border-secondary);
}

.link-color {
  color: var(--link-color);
}

.font-family-inter {
  font-family: var(--font-inter);
}

src\assests\scss\_variables.scss
:root {
  --font-inter: "Inter", sans-serif;

  /* Background Colors */
  --bg-primary: #fff; /* Colors/Background/bg-primary */
  --bg-secondary: #f9fafb; /* Colors/Background/bg-secondary */
  --bg-page: #f5f5f5; /* General page background color */

  /* Text Colors */
  --text-white: #fff; /* Colors/Text/text-primary (900) */
  --text-primary: #101828; /* Colors/Text/text-primary (900) */
  --text-secondary: #344054; /* Colors/Text/text-secondary (700) */
  --text-tertiary: #475467; /* Colors/Text/text-tertiary (600) */
  --text-placeholder: #667085; /* Placeholder color for forms/inputs */

  /* Button Colors */
  --button-primary-bg: #7f56d9; /* Background color for primary buttons */
  --button-primary-border: #7f56d9; /* Border color for primary buttons */
  --button-tertiary-color: #6941c6; /* Text color for secondary buttons */
  --button-tertiary-border: #d6bbfb; /* Border color for secondary buttons */
  --button-secondary-color: #344054; /* Text color for secondary buttons */

  /* Border Colors */
  --border-primary: #d0d5dd; /* Border color for buttons and main forms */
  --border-secondary: #eaecf0; /* Border color for titles, forms, and menu items */

  /* Miscellaneous */
  --link-color: #475467; /* Color for <a> tags */
}

